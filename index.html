<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Show Diff Widget</title>
    <!-- Highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 14px;
            width: 100%;
        }

        .widget-container {
            width: 100%;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .control-panel {
            display: flex;
            align-items: center;
            margin-left: 16px;
        }

        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            margin-right: 8px;
            white-space: nowrap;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .diff-container {
            background: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .diff-header {
            padding: 12px 16px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            font-weight: 600;
            color: #495057;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .diff-header-title {
            flex: 1;
        }

        .diff-header-status {
            font-size: 12px;
            font-weight: normal;
            color: #28a745;
            margin-left: 16px;
        }

        .auto-update-control {
            display: flex;
            align-items: center;
            font-size: 12px;
            font-weight: normal;
            color: #495057;
        }

        .auto-update-control input[type="checkbox"] {
            margin-right: 4px;
            cursor: pointer;
        }

        .auto-update-control label {
            cursor: pointer;
            user-select: none;
        }

        .view-toggle {
            display: flex;
            gap: 4px;
            background: #fff;
            border-radius: 4px;
            padding: 2px;
            border: 1px solid #dee2e6;
        }

        .view-toggle button {
            padding: 4px 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
            transition: all 0.2s;
            color: #495057;
        }

        .view-toggle button:hover {
            background: #e9ecef;
        }

        .view-toggle button.active {
            background: #007bff;
            color: white;
        }

        /* Split view styles */
        .diff-split-view {
            display: flex;
            width: 100%;
            min-height: 400px;
        }

        .diff-split-pane {
            flex: 1;
            width: 50%;
            overflow-x: auto;
            border-right: 2px solid #e1e4e8;
        }

        .diff-split-pane:last-child {
            border-right: none;
        }

        .diff-split-header {
            padding: 8px 12px;
            background: #f6f8fa;
            border-bottom: 1px solid #e1e4e8;
            font-weight: 600;
            font-size: 13px;
            color: #24292e;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .diff-split-header.removed {
            background: #ffeef0;
            border-bottom-color: #fdb8c0;
        }

        .diff-split-header.added {
            background: #e6ffed;
            border-bottom-color: #9be9a8;
        }

        .diff-split-content {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .diff-split-line {
            display: flex;
            min-height: 20px;
            padding: 2px 0;
        }

        .diff-split-line.removed {
            background: #ffeef0;
        }

        .diff-split-line.added {
            background: #e6ffed;
        }

        .diff-split-line.unchanged {
            background: white;
        }

        .diff-split-line.empty {
            background: #fafbfc;
        }

        .split-line-number {
            min-width: 50px;
            padding: 0 8px;
            text-align: right;
            color: rgba(27,31,35,0.3);
            user-select: none;
            flex-shrink: 0;
            font-size: 12px;
            background: #f6f8fa;
            border-right: 1px solid #e1e4e8;
        }

        .split-line-content {
            flex: 1;
            padding: 0 12px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .split-line-content code {
            background: none;
            padding: 0;
            font-family: inherit;
            font-size: inherit;
        }

        .split-line-content .hljs {
            background: transparent;
            padding: 0;
            overflow: visible;
        }

        .diff-split-line.removed .char-diff {
            background: rgba(215, 58, 73, 0.4);
        }

        .diff-split-line.added .char-diff {
            background: rgba(34, 134, 58, 0.4);
        }

        .diff-content {
            padding: 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;
            font-size: 13px;
            line-height: 1.6;
            overflow-x: auto;
        }

        .diff-line {
            display: flex;
            min-height: 20px;
            padding: 2px 0;
        }

        .line-number {
            min-width: 90px;
            padding: 0 8px;
            text-align: right;
            color: rgba(27,31,35,0.3);
            user-select: none;
            flex-shrink: 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            gap: 4px;
            background: #f6f8fa;
            border-right: 1px solid #e1e4e8;
        }
        
        .line-number-old {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            padding-right: 8px;
            border-right: 1px solid #e1e4e8;
        }
        
        .line-number-new {
            display: inline-block;
            min-width: 40px;
            text-align: right;
        }

        .line-content {
            flex: 1;
            padding: 0 12px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Syntax highlighting styles */
        .line-content code {
            background: none;
            padding: 0;
            font-family: inherit;
            font-size: inherit;
        }

        .line-content .hljs {
            background: transparent;
            padding: 0;
            overflow: visible;
        }

        .char-diff {
            background: rgba(255, 200, 0, 0.5);
            font-weight: 700;
            padding: 1px 2px;
            border-radius: 2px;
        }

        /* New explicit char-level diff highlight colors for additions and deletions */
        .char-add {
            background: #a7e9ba; /* slightly darker soft green */
            color: inherit; /* keep original code color */
            font-weight: 600;
            padding: 1px 2px;
            border-radius: 2px;
        }
        .char-del {
            background: #ffbfc9; /* slightly darker soft red */
            color: inherit; /* keep original code color */
            font-weight: 600;
            padding: 1px 2px;
            border-radius: 2px;
        }

        .diff-line.added .char-diff {
            background: rgba(34, 134, 58, 0.35); /* darken for better contrast */
            color: inherit;
        }

        .diff-line.removed .char-diff {
            background: rgba(215, 58, 73, 0.35); /* darken for better contrast */
            color: inherit;
        }

        .diff-line.added {
            background: #e6ffed;
        }

        .diff-line.added .line-content {
            color: #24292e;
        }

        .diff-line.added::before {
            content: '+';
            color: #22863a;
            padding: 0 8px;
            font-weight: bold;
            min-width: 24px;
            display: inline-block;
            text-align: center;
        }

        .diff-line.removed {
            background: #ffeef0;
        }

        .diff-line.removed .line-content {
            color: #24292e;
        }

        .diff-line.removed::before {
            content: '-';
            color: #d73a49;
            padding: 0 8px;
            font-weight: bold;
            min-width: 24px;
            display: inline-block;
            text-align: center;
        }

        .diff-line.unchanged {
            background: white;
        }

        .diff-line.unchanged::before {
            content: ' ';
            padding: 0 8px;
            min-width: 24px;
            display: inline-block;
            text-align: center;
        }

        .empty-state {
            padding: 40px;
            text-align: center;
            color: #6c757d;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .status-message {
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 4px;
            font-size: 14px;
        }

        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .loading {
            padding: 20px;
            text-align: center;
            color: #6c757d;
        }

        .diff-stats {
            padding: 12px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-size: 13px;
            color: #495057;
        }

        .diff-stats span {
            margin-right: 16px;
        }

        .added-count {
            color: #28a745;
            font-weight: 600;
        }

        .removed-count {
            color: #dc3545;
            font-weight: 600;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
        .diff-content::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .diff-content::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 4px;
        }

        .diff-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .diff-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Firefox æ»šåŠ¨æ¡æ ·å¼ */
        .diff-content {
            scrollbar-width: thin;
            scrollbar-color: #888 #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="widget-container">
        <div id="statusMessage"></div>
        
        <div class="diff-container">
            <div class="diff-header">
                <span class="diff-header-title">å·®å¼‚å¯¹æ¯”ç»“æœ</span>
                <span id="headerStatus" class="diff-header-status"></span>
                <div class="control-panel">
                    <button id="insertBtn" class="btn btn-primary">ğŸ“ æ’å…¥å¯¹æ¯”æ¨¡æ¿</button>
                    <button id="refreshBtn" class="btn btn-success">ğŸ”„ åˆ·æ–°å¯¹æ¯”</button>
                </div>
                <div class="view-toggle">
                    <button id="unifiedViewBtn" class="active">ç»Ÿä¸€è§†å›¾</button>
                    <button id="splitViewBtn">åˆ†æ è§†å›¾</button>
                </div>
                <div class="auto-update-control">
                    <input type="checkbox" id="autoUpdateCheckbox" checked>
                    <label for="autoUpdateCheckbox">è‡ªåŠ¨æ›´æ–°</label>
                </div>
            </div>
            <div id="diffContent" class="diff-content">
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ“Š</div>
                    <p id="emptyStateText">ç­‰å¾…åŠ è½½å¯¹æ¯”æ•°æ®...</p>
                    <p id="emptyStateHint" style="font-size: 12px; color: #adb5bd;">è¯·åœ¨æ­¤æŒ‚ä»¶ä¸Šæ–¹æ’å…¥å¯¹æ¯”æ¨¡æ¿æˆ–æ‰‹åŠ¨åˆ›å»ºåŒ…å«å·¦å³ä»£ç å—çš„è¶…çº§å—</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // è·å–æŒ‚ä»¶æ‰€åœ¨å—çš„ID
        const widgetId = window.frameElement?.parentElement?.parentElement?.dataset?.nodeId;

        // Internationalization
        const i18n = {
            'zh_CN': {
                diffTitle: 'å·®å¼‚å¯¹æ¯”ç»“æœ',
                insertTemplate: 'ğŸ“ æ’å…¥å¯¹æ¯”æ¨¡æ¿',
                refresh: 'ğŸ”„ åˆ·æ–°å¯¹æ¯”',
                autoUpdate: 'è‡ªåŠ¨æ›´æ–°',
                unifiedView: 'ç»Ÿä¸€è§†å›¾',
                splitView: 'åˆ†æ è§†å›¾',
                originalCode: 'åŸå§‹ä»£ç ',
                modifiedCode: 'ä¿®æ”¹åä»£ç ',
                waitingForData: 'ç­‰å¾…åŠ è½½å¯¹æ¯”æ•°æ®...',
                insertTemplateHint: 'è¯·åœ¨æ­¤æŒ‚ä»¶ä¸Šæ–¹æ’å…¥å¯¹æ¯”æ¨¡æ¿æˆ–æ‰‹åŠ¨åˆ›å»ºåŒ…å«å·¦å³ä»£ç å—çš„è¶…çº§å—',
                identical: 'ä¸¤æ®µä»£ç å®Œå…¨ç›¸åŒ',
                added: 'æ–°å¢',
                removed: 'åˆ é™¤',
                loading: 'æ­£åœ¨åŠ è½½...',
                emptyCode: 'ä»£ç å—ä¸ºç©º',
                loadFailed: 'åŠ è½½å¤±è´¥',
                templateInserted: 'æ¨¡æ¿å·²æ’å…¥åˆ°æŒ‚ä»¶ä¸Šæ–¹',
                templateInsertFailed: 'æ’å…¥æ¨¡æ¿å¤±è´¥',
                updated: 'å·²æ›´æ–°',
                emptyCodeBlock: 'ä»£ç å—ä¸ºç©ºï¼Œè¯·æ·»åŠ ä»£ç å†…å®¹',
                enterFirstCode: 'åœ¨è¿™é‡Œè¾“å…¥ç¬¬ä¸€æ®µä»£ç ',
                enterSecondCode: 'åœ¨è¿™é‡Œè¾“å…¥ç¬¬äºŒæ®µä»£ç ',
                widgetIdError: 'æ— æ³•è·å–æŒ‚ä»¶IDï¼Œè¯·æ£€æŸ¥æŒ‚ä»¶é…ç½®',
                errorWidgetId: 'æ— æ³•è·å–æŒ‚ä»¶ID',
                errorWidgetInfo: 'æ— æ³•è·å–æŒ‚ä»¶å—ä¿¡æ¯',
                errorDocBlocks: 'æ— æ³•è·å–æ–‡æ¡£å—',
                errorFindWidget: 'æ— æ³•æ‰¾åˆ°æŒ‚ä»¶å—',
                errorNoSuperBlock: 'åœ¨æŒ‚ä»¶ä¸Šæ–¹æœªæ‰¾åˆ°è¶…çº§å—',
                errorInsufficientBlocks: 'è¶…çº§å—ä¸­ä»£ç å—æ•°é‡ä¸è¶³ï¼ˆéœ€è¦è‡³å°‘2ä¸ªï¼‰',
                errorInsufficientCodeBlocks: 'è¶…çº§å—ä¸­æœªæ‰¾åˆ°è¶³å¤Ÿçš„ä»£ç å—ï¼ˆéœ€è¦è‡³å°‘2ä¸ªï¼‰'
            },
            'en_US': {
                diffTitle: 'Diff Comparison Result',
                insertTemplate: 'ğŸ“ Insert Template',
                refresh: 'ğŸ”„ Refresh',
                autoUpdate: 'Auto Update',
                unifiedView: 'Unified',
                splitView: 'Split',
                originalCode: 'Original Code',
                modifiedCode: 'Modified Code',
                waitingForData: 'Waiting for comparison data...',
                insertTemplateHint: 'Please insert a comparison template above this widget or manually create a super block containing left and right code blocks',
                identical: 'Both code blocks are identical',
                added: 'Added',
                removed: 'Removed',
                loading: 'Loading...',
                emptyCode: 'Code block is empty',
                loadFailed: 'Load failed',
                templateInserted: 'Template inserted above widget',
                templateInsertFailed: 'Failed to insert template',
                updated: 'Updated',
                emptyCodeBlock: 'Code block is empty, please add code content',
                enterFirstCode: 'Enter the first code snippet here',
                enterSecondCode: 'Enter the second code snippet here',
                widgetIdError: 'Cannot get widget ID, please check widget configuration',
                errorWidgetId: 'Cannot get widget ID',
                errorWidgetInfo: 'Cannot get widget block info',
                errorDocBlocks: 'Cannot get document blocks',
                errorFindWidget: 'Cannot find widget block',
                errorNoSuperBlock: 'No super block found above widget',
                errorInsufficientBlocks: 'Insufficient code blocks in super block (at least 2 required)',
                errorInsufficientCodeBlocks: 'Not enough code blocks found in super block (at least 2 required)'
            }
        };

        let currentLang = 'zh_CN';
        let t = i18n[currentLang];
        let currentView = 'unified'; // 'unified' or 'split'
        let currentDiffData = null; // Store current diff data for view switching

        // Get SiYuan language setting
        async function getSiYuanLang() {
            try {
                const response = await callAPI('/api/system/getConf', {});
                console.log('SiYuan config response:', response);
                if (response.code === 0 && response.data && response.data.lang) {
                    console.log('Detected language:', response.data.lang);
                    currentLang = response.data.lang;
                    if (!i18n[currentLang]) {
                        console.log('Language not supported, falling back to zh_CN');
                        currentLang = 'zh_CN';
                    }
                    t = i18n[currentLang];
                    console.log('Current language set to:', currentLang);
                    updateUILanguage();
                } else {
                    console.log('Could not get language from response, using default zh_CN');
                }
            } catch (error) {
                console.error('Failed to get language setting:', error);
            }
        }

        // Update UI text based on current language
        function updateUILanguage() {
            document.querySelector('.diff-header-title').textContent = t.diffTitle;
            document.getElementById('insertBtn').innerHTML = t.insertTemplate;
            document.getElementById('refreshBtn').innerHTML = t.refresh;
            document.getElementById('unifiedViewBtn').textContent = t.unifiedView;
            document.getElementById('splitViewBtn').textContent = t.splitView;
            document.querySelector('.auto-update-control label').textContent = t.autoUpdate;
            
            const emptyStateText = document.getElementById('emptyStateText');
            const emptyStateHint = document.getElementById('emptyStateHint');
            if (emptyStateText) emptyStateText.textContent = t.waitingForData;
            if (emptyStateHint) emptyStateHint.textContent = t.insertTemplateHint;
        }

        // Myers diff algorithm implementation with improved line matching
        function computeDiff(text1, text2) {
            const lines1 = text1.split('\n');
            const lines2 = text2.split('\n');
            
            // Use a simpler LCS-based approach for better line pairing
            const diff = [];
            const lcs = longestCommonSubsequence(lines1, lines2);
            
            let i = 0, j = 0;
            for (const [line1Idx, line2Idx] of lcs) {
                // Add removed lines before this match
                while (i < line1Idx) {
                    diff.push({
                        type: 'removed',
                        content: lines1[i],
                        oldLine: i + 1,
                        newLine: null
                    });
                    i++;
                }
                
                // Add added lines before this match
                while (j < line2Idx) {
                    diff.push({
                        type: 'added',
                        content: lines2[j],
                        oldLine: null,
                        newLine: j + 1
                    });
                    j++;
                }
                
                // Add the matching line
                diff.push({
                    type: 'unchanged',
                    content: lines1[i],
                    oldLine: i + 1,
                    newLine: j + 1
                });
                i++;
                j++;
            }
            
            // Add remaining removed lines
            while (i < lines1.length) {
                diff.push({
                    type: 'removed',
                    content: lines1[i],
                    oldLine: i + 1,
                    newLine: null
                });
                i++;
            }
            
            // Add remaining added lines
            while (j < lines2.length) {
                diff.push({
                    type: 'added',
                    content: lines2[j],
                    oldLine: null,
                    newLine: j + 1
                });
                j++;
            }
            
            return diff;
        }
        
        // Longest Common Subsequence algorithm
        function longestCommonSubsequence(arr1, arr2) {
            const m = arr1.length;
            const n = arr2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            
            // Build LCS length table
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (arr1[i - 1] === arr2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                    }
                }
            }
            
            // Backtrack to find the actual LCS
            const lcs = [];
            let i = m, j = n;
            while (i > 0 && j > 0) {
                if (arr1[i - 1] === arr2[j - 1]) {
                    lcs.unshift([i - 1, j - 1]);
                    i--;
                    j--;
                } else if (dp[i - 1][j] > dp[i][j - 1]) {
                    i--;
                } else {
                    j--;
                }
            }
            
            return lcs;
        }

        // Apply syntax highlighting to code
        function highlightCode(code, language) {
            try {
                if (language && hljs.getLanguage(language)) {
                    return hljs.highlight(code, { language: language }).value;
                } else {
                    return hljs.highlightAuto(code).value;
                }
            } catch (e) {
                console.error('Syntax highlighting error:', e);
                return escapeHtml(code);
            }
        }

        // Character-level diff for modified lines with syntax highlighting
        function getCharDiff(oldStr, newStr, language) {
            if (!oldStr || !newStr) {
                const oldHighlighted = oldStr ? highlightCode(oldStr, language) : '';
                const newHighlighted = newStr ? highlightCode(newStr, language) : '';
                return { old: oldHighlighted, new: newHighlighted };
            }
            
            const oldChars = oldStr.split('');
            const newChars = newStr.split('');
            const n = oldChars.length;
            const m = newChars.length;
            
            // Find common prefix
            let prefixLen = 0;
            while (prefixLen < n && prefixLen < m && oldChars[prefixLen] === newChars[prefixLen]) {
                prefixLen++;
            }
            
            // Find common suffix
            let suffixLen = 0;
            while (suffixLen < n - prefixLen && suffixLen < m - prefixLen && 
                   oldChars[n - 1 - suffixLen] === newChars[m - 1 - suffixLen]) {
                suffixLen++;
            }
            
            const prefix = highlightCode(oldStr.substring(0, prefixLen), language);
            const suffix = highlightCode(oldStr.substring(n - suffixLen), language);
            const oldMiddle = oldStr.substring(prefixLen, n - suffixLen);
            const newMiddle = newStr.substring(prefixLen, m - suffixLen);
            
            // Use distinct classes for removed (old) and added (new) segments
            const oldResult = prefix + 
                (oldMiddle ? `<span class="char-del">${highlightCode(oldMiddle, language)}</span>` : '') + 
                suffix;
            const newResult = prefix + 
                (newMiddle ? `<span class="char-add">${highlightCode(newMiddle, language)}</span>` : '') + 
                suffix;
            
            return { old: oldResult, new: newResult };
        }

        // Self-test to verify new char-add / char-del highlighting (console only)
        (function() {
            try {
                const sample = getCharDiff('const value = 1;', 'const value = 10;', 'javascript');
                console.log('[sy-widget-show-diff] char diff sample (old/new):', sample);
            } catch (e) {
                console.warn('[sy-widget-show-diff] char diff self-test failed:', e);
            }
        })();

        // Render split view
        function renderSplitView(leftLines, rightLines, language = 'plaintext') {
            const container = document.getElementById('diffContent');
            
            // Calculate statistics
            let addedCount = 0;
            let removedCount = 0;
            rightLines.forEach(line => { if (line && line.type === 'added') addedCount++; });
            leftLines.forEach(line => { if (line && line.type === 'removed') removedCount++; });
            
            let html = `
                <div class="diff-stats">
                    <span class="added-count">+${addedCount} ${t.added}</span>
                    <span class="removed-count">-${removedCount} ${t.removed}</span>
                </div>
                <div class="diff-split-view">
                    <div class="diff-split-pane">
                        <div class="diff-split-header removed">${t.originalCode}</div>
                        <div class="diff-split-content">
            `;
            
            // Render left pane (original)
            leftLines.forEach(line => {
                if (!line) {
                    html += `
                        <div class="diff-split-line empty">
                            <span class="split-line-number"></span>
                            <span class="split-line-content"></span>
                        </div>
                    `;
                } else {
                    const content = line.isHtml ? line.content : highlightCode(line.content, language);
                    const lineClass = line.type === 'removed' ? 'removed' : (line.type === 'unchanged' ? 'unchanged' : 'empty');
                    html += `
                        <div class="diff-split-line ${lineClass}">
                            <span class="split-line-number">${line.oldLine || ''}</span>
                            <span class="split-line-content">${content}</span>
                        </div>
                    `;
                }
            });
            
            html += `
                        </div>
                    </div>
                    <div class="diff-split-pane">
                        <div class="diff-split-header added">${t.modifiedCode}</div>
                        <div class="diff-split-content">
            `;
            
            // Render right pane (modified)
            rightLines.forEach(line => {
                if (!line) {
                    html += `
                        <div class="diff-split-line empty">
                            <span class="split-line-number"></span>
                            <span class="split-line-content"></span>
                        </div>
                    `;
                } else {
                    const content = line.isHtml ? line.content : highlightCode(line.content, language);
                    const lineClass = line.type === 'added' ? 'added' : (line.type === 'unchanged' ? 'unchanged' : 'empty');
                    html += `
                        <div class="diff-split-line ${lineClass}">
                            <span class="split-line-number">${line.newLine || ''}</span>
                            <span class="split-line-content">${content}</span>
                        </div>
                    `;
                }
            });
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        // Convert unified diff to split view format
        function convertToSplitFormat(diffResult, language = 'plaintext') {
            const leftLines = [];
            const rightLines = [];
            
            let i = 0;
            while (i < diffResult.length) {
                const curr = diffResult[i];
                
                if (curr.type === 'unchanged') {
                    // Both sides show the same line
                    leftLines.push({
                        ...curr,
                        content: curr.isHtml ? curr.content : highlightCode(curr.content, language),
                        isHtml: true
                    });
                    rightLines.push({
                        ...curr,
                        content: curr.isHtml ? curr.content : highlightCode(curr.content, language),
                        isHtml: true
                    });
                    i++;
                } else if (curr.type === 'removed') {
                    // Stable block handling for removed + added lines preserving original order
                    // Collect consecutive removed lines
                    const removedBlock = [];
                    while (i < diffResult.length && diffResult[i].type === 'removed') {
                        removedBlock.push(diffResult[i]);
                        i++;
                    }
                    // Collect consecutive added lines directly following
                    const addedBlock = [];
                    while (i < diffResult.length && diffResult[i].type === 'added') {
                        addedBlock.push(diffResult[i]);
                        i++;
                    }

                    if (removedBlock.length && addedBlock.length) {
                        // Pair lines by index (stable) to keep ascending line numbers.
                        const pairCount = Math.min(removedBlock.length, addedBlock.length);
                        for (let k = 0; k < pairCount; k++) {
                            const rem = removedBlock[k];
                            const add = addedBlock[k];
                            const charDiff = getCharDiff(rem.content, add.content, language);
                            leftLines.push({
                                type: 'removed',
                                content: charDiff.old,
                                oldLine: rem.oldLine,
                                newLine: null,
                                isHtml: true
                            });
                            rightLines.push({
                                type: 'added',
                                content: charDiff.new,
                                oldLine: null,
                                newLine: add.newLine,
                                isHtml: true
                            });
                        }
                        // Remaining removed lines (if any)
                        for (let k = pairCount; k < removedBlock.length; k++) {
                            const rem = removedBlock[k];
                            leftLines.push({
                                ...rem,
                                content: rem.isHtml ? rem.content : highlightCode(rem.content, language),
                                isHtml: true
                            });
                            rightLines.push(null);
                        }
                        // Remaining added lines (if any)
                        for (let k = pairCount; k < addedBlock.length; k++) {
                            const add = addedBlock[k];
                            leftLines.push(null);
                            rightLines.push({
                                ...add,
                                content: add.isHtml ? add.content : highlightCode(add.content, language),
                                isHtml: true
                            });
                        }
                    } else if (removedBlock.length) {
                        removedBlock.forEach(rem => {
                            leftLines.push({
                                ...rem,
                                content: rem.isHtml ? rem.content : highlightCode(rem.content, language),
                                isHtml: true
                            });
                            rightLines.push(null);
                        });
                    } else if (addedBlock.length) {
                        addedBlock.forEach(add => {
                            leftLines.push(null);
                            rightLines.push({
                                ...add,
                                content: add.isHtml ? add.content : highlightCode(add.content, language),
                                isHtml: true
                            });
                        });
                    }
                } else if (curr.type === 'added') {
                    // Only added, empty on left, show on right
                    leftLines.push(null);
                    rightLines.push({
                        ...curr,
                        content: curr.isHtml ? curr.content : highlightCode(curr.content, language),
                        isHtml: true
                    });
                    i++;
                }
            }
            
            return { leftLines, rightLines };
        }

        // æ¸²æŸ“diffç»“æœ (unified view)
        function renderDiff(diffResult, language = 'plaintext') {
            const container = document.getElementById('diffContent');
            
            if (diffResult.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">âœ…</div>
                        <p>${t.identical}</p>
                    </div>
                `;
                return;
            }

            // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
            const stats = diffResult.reduce((acc, line) => {
                if (line.type === 'added') acc.added++;
                if (line.type === 'removed') acc.removed++;
                return acc;
            }, { added: 0, removed: 0 });

            let html = `
                <div class="diff-stats">
                    <span class="added-count">+${stats.added} ${t.added}</span>
                    <span class="removed-count">-${stats.removed} ${t.removed}</span>
                </div>
            `;

            // Improved grouping with better similarity detection
            const grouped = [];
            let i = 0;
            
            while (i < diffResult.length) {
                const curr = diffResult[i];
                
                if (curr.type === 'unchanged') {
                    grouped.push({
                        ...curr,
                        content: highlightCode(curr.content, language),
                        isHtml: true
                    });
                    i++;
                    continue;
                }
                
                // Collect consecutive removed lines
                const removedBlock = [];
                while (i < diffResult.length && diffResult[i].type === 'removed') {
                    removedBlock.push(diffResult[i]);
                    i++;
                }
                
                // Collect consecutive added lines
                const addedBlock = [];
                while (i < diffResult.length && diffResult[i].type === 'added') {
                    addedBlock.push(diffResult[i]);
                    i++;
                }
                
                // If we have both removed and added lines, try to pair similar ones
                if (removedBlock.length > 0 && addedBlock.length > 0) {
                    // Calculate similarity scores for all pairs
                    const pairs = [];
                    for (let r = 0; r < removedBlock.length; r++) {
                        for (let a = 0; a < addedBlock.length; a++) {
                            const similarity = calculateSimilarity(removedBlock[r].content, addedBlock[a].content);
                            pairs.push({ r, a, similarity });
                        }
                    }
                    
                    // Sort by similarity (highest first)
                    pairs.sort((a, b) => b.similarity - a.similarity);
                    
                    const usedRemoved = new Set();
                    const usedAdded = new Set();
                    const pairedItems = [];
                    
                    // Pair lines with similarity > 0.3 (threshold for considering them modified versions)
                    for (const pair of pairs) {
                        if (!usedRemoved.has(pair.r) && !usedAdded.has(pair.a) && pair.similarity > 0.3) {
                            usedRemoved.add(pair.r);
                            usedAdded.add(pair.a);
                            
                            const charDiff = getCharDiff(removedBlock[pair.r].content, addedBlock[pair.a].content, language);
                            pairedItems.push({
                                removedIndex: pair.r,
                                addedIndex: pair.a,
                                removed: {
                                    type: 'removed',
                                    content: charDiff.old,
                                    oldLine: removedBlock[pair.r].oldLine,
                                    newLine: null,
                                    isHtml: true
                                },
                                added: {
                                    type: 'added',
                                    content: charDiff.new,
                                    oldLine: null,
                                    newLine: addedBlock[pair.a].newLine,
                                    isHtml: true
                                }
                            });
                        }
                    }
                    
                    // Sort paired items by their original order
                    pairedItems.sort((a, b) => a.removedIndex - b.removedIndex);
                    
                    // Add all lines in proper order
                    let removedIdx = 0;
                    let addedIdx = 0;
                    
                    for (const pairedItem of pairedItems) {
                        // Add unpaired removed lines before this pair
                        while (removedIdx < pairedItem.removedIndex) {
                            if (!usedRemoved.has(removedIdx)) {
                                grouped.push({
                                    ...removedBlock[removedIdx],
                                    content: highlightCode(removedBlock[removedIdx].content, language),
                                    isHtml: true
                                });
                            }
                            removedIdx++;
                        }
                        
                        // Add unpaired added lines before this pair
                        while (addedIdx < pairedItem.addedIndex) {
                            if (!usedAdded.has(addedIdx)) {
                                grouped.push({
                                    ...addedBlock[addedIdx],
                                    content: highlightCode(addedBlock[addedIdx].content, language),
                                    isHtml: true
                                });
                            }
                            addedIdx++;
                        }
                        
                        // Add the paired lines
                        grouped.push(pairedItem.removed);
                        grouped.push(pairedItem.added);
                        removedIdx++;
                        addedIdx++;
                    }
                    
                    // Add remaining unpaired lines
                    while (removedIdx < removedBlock.length) {
                        if (!usedRemoved.has(removedIdx)) {
                            grouped.push({
                                ...removedBlock[removedIdx],
                                content: highlightCode(removedBlock[removedIdx].content, language),
                                isHtml: true
                            });
                        }
                        removedIdx++;
                    }
                    
                    while (addedIdx < addedBlock.length) {
                        if (!usedAdded.has(addedIdx)) {
                            grouped.push({
                                ...addedBlock[addedIdx],
                                content: highlightCode(addedBlock[addedIdx].content, language),
                                isHtml: true
                            });
                        }
                        addedIdx++;
                    }
                } else if (removedBlock.length > 0) {
                    // Only removed lines
                    removedBlock.forEach(line => {
                        grouped.push({
                            ...line,
                            content: highlightCode(line.content, language),
                            isHtml: true
                        });
                    });
                } else if (addedBlock.length > 0) {
                    // Only added lines
                    addedBlock.forEach(line => {
                        grouped.push({
                            ...line,
                            content: highlightCode(line.content, language),
                            isHtml: true
                        });
                    });
                }
            }

            // Render with proper line numbers showing original positions (GitHub style)
            grouped.forEach(line => {
                const content = line.isHtml ? line.content : highlightCode(line.content, language);
                
                // Show line numbers in GitHub style - old line | new line
                let lineNumbers = '';
                const oldLineNum = line.oldLine || '';
                const newLineNum = line.newLine || '';
                
                lineNumbers = `<span class="line-number-old">${oldLineNum}</span><span class="line-number-new">${newLineNum}</span>`;
                
                html += `
                    <div class="diff-line ${line.type}">
                        <span class="line-number">${lineNumbers}</span>
                        <span class="line-content">${content}</span>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Render current view
        function renderCurrentView() {
            if (!currentDiffData) return;
            
            if (currentView === 'split') {
                const { leftLines, rightLines } = convertToSplitFormat(currentDiffData.diffResult, currentDiffData.language);
                renderSplitView(leftLines, rightLines, currentDiffData.language);
            } else {
                renderDiff(currentDiffData.diffResult, currentDiffData.language);
            }
        }

        // Switch view
        function switchView(view) {
            if (view === currentView) return;
            
            currentView = view;
            
            // Update button states
            document.getElementById('unifiedViewBtn').classList.toggle('active', view === 'unified');
            document.getElementById('splitViewBtn').classList.toggle('active', view === 'split');
            
            // Re-render with new view
            renderCurrentView();
            
            // Save preference
            localStorage.setItem('sy-widget-show-diff-view', view);
        }

        // Calculate similarity between two strings (0 to 1)
        function calculateSimilarity(str1, str2) {
            if (str1 === str2) return 1;
            if (!str1 || !str2) return 0;
            
            const len1 = str1.length;
            const len2 = str2.length;
            const maxLen = Math.max(len1, len2);
            
            if (maxLen === 0) return 1;
            
            // Use Levenshtein distance
            const distance = levenshteinDistance(str1, str2);
            return 1 - distance / maxLen;
        }
        
        // Levenshtein distance algorithm
        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const dp = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));
            
            for (let i = 0; i <= len1; i++) dp[i][0] = i;
            for (let j = 0; j <= len2; j++) dp[0][j] = j;
            
            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (str1[i - 1] === str2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = Math.min(
                            dp[i - 1][j] + 1,     // deletion
                            dp[i][j - 1] + 1,     // insertion
                            dp[i - 1][j - 1] + 1  // substitution
                        );
                    }
                }
            }
            
            return dp[len1][len2];
        }
        
        // HTMLè½¬ä¹‰
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯ï¼ˆåœ¨headerä¸­æ˜¾ç¤ºï¼‰
        function showHeaderStatus(message) {
            const headerStatus = document.getElementById('headerStatus');
            headerStatus.textContent = message;
            setTimeout(() => {
                headerStatus.textContent = '';
            }, 3000);
        }

        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼ˆä½¿ç”¨æ—§çš„å¼¹å‡ºæ ·å¼ï¼‰
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 3000);
        }

        // è°ƒç”¨æ€æºAPI
        async function callAPI(url, data) {
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                return await response.json();
            } catch (error) {
                console.error('APIè°ƒç”¨å¤±è´¥:', error);
                throw error;
            }
        }

        // è·å–ä¸Šæ–¹çš„è¶…çº§å—
        async function getSuperBlockAbove() {
            if (!widgetId) {
                throw new Error(t.errorWidgetId);
            }

            // è·å–æŒ‚ä»¶çš„çˆ¶å—
            const widgetBlock = await callAPI('/api/block/getBlockInfo', { id: widgetId });
            if (!widgetBlock.data) {
                throw new Error(t.errorWidgetInfo);
            }

            // è·å–çˆ¶æ–‡æ¡£çš„æ‰€æœ‰å­å—
            const parentId = widgetBlock.data.rootID;
            const docBlocks = await callAPI('/api/block/getChildBlocks', { id: parentId });
            
            if (!docBlocks.data) {
                throw new Error(t.errorDocBlocks);
            }

            // æ‰¾åˆ°æŒ‚ä»¶å—çš„ä½ç½®ï¼Œç„¶åæ‰¾ä¸Šä¸€ä¸ªè¶…çº§å—
            const blocks = docBlocks.data;
            const widgetIndex = blocks.findIndex(b => b.id === widgetId);
            
            if (widgetIndex === -1) {
                throw new Error(t.errorFindWidget);
            }

            // ä»æŒ‚ä»¶å¾€ä¸Šæ‰¾ç¬¬ä¸€ä¸ªè¶…çº§å—
            for (let i = widgetIndex - 1; i >= 0; i--) {
                if (blocks[i].type === 's') {  // 's' è¡¨ç¤ºè¶…çº§å—
                    return blocks[i];
                }
            }

            throw new Error(t.errorNoSuperBlock);
        }

        // æå–è¶…çº§å—ä¸­çš„å·¦å³ä»£ç å—å†…å®¹
        async function extractCodeBlocks(superBlockId) {
            const childBlocks = await callAPI('/api/block/getChildBlocks', { id: superBlockId });
            
            if (!childBlocks.data || childBlocks.data.length < 2) {
                throw new Error(t.errorInsufficientBlocks);
            }

            const codeBlocks = childBlocks.data.filter(block => block.type === 'c');  // 'c' è¡¨ç¤ºä»£ç å—
            
            if (codeBlocks.length < 2) {
                throw new Error(t.errorInsufficientCodeBlocks);
            }

            // è·å–å‰ä¸¤ä¸ªä»£ç å—çš„å†…å®¹
            const leftBlock = await callAPI('/api/block/getBlockKramdown', { id: codeBlocks[0].id });
            const rightBlock = await callAPI('/api/block/getBlockKramdown', { id: codeBlocks[1].id });

            // ä»Kramdownä¸­æå–ä»£ç å†…å®¹å’Œè¯­è¨€
            const leftData = extractCodeContent(leftBlock.data.kramdown);
            const rightData = extractCodeContent(rightBlock.data.kramdown);

            return { 
                left: leftData.content, 
                right: rightData.content,
                language: leftData.language || rightData.language || 'plaintext'
            };
        }

        // ä»Kramdownæå–ä»£ç å†…å®¹å’Œè¯­è¨€
        function extractCodeContent(kramdown) {
            // åŒ¹é…ä»£ç å—: ```language\ncode\n```
            const match = kramdown.match(/```([\w]*)\n([\s\S]*?)```/);
            if (match) {
                return {
                    content: match[2] ? match[2].trim() : '',
                    language: match[1] || ''
                };
            }
            return { content: '', language: '' };
        }

        // åŠ è½½å¹¶æ˜¾ç¤ºdiff
        async function loadAndShowDiff() {
            try {
                document.getElementById('diffContent').innerHTML = `<div class="loading">${t.loading}</div>`;
                
                const superBlock = await getSuperBlockAbove();
                const { left, right, language } = await extractCodeBlocks(superBlock.id);

                if (!left && !right) {
                    showStatus(t.emptyCodeBlock, 'error');
                    document.getElementById('diffContent').innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">âš ï¸</div>
                            <p>${t.emptyCode}</p>
                        </div>
                    `;
                    currentDiffData = null;
                    return;
                }

                const diffResult = computeDiff(left, right);
                
                // Store diff data for view switching
                currentDiffData = {
                    diffResult: diffResult,
                    language: language
                };
                
                // Render based on current view
                renderCurrentView();
                showHeaderStatus(t.updated);

            } catch (error) {
                console.error('Load failed:', error);
                showStatus(error.message, 'error');
                document.getElementById('diffContent').innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">âŒ</div>
                        <p>${t.loadFailed}: ${error.message}</p>
                    </div>
                `;
                currentDiffData = null;
            }
        }

        // æ’å…¥å¯¹æ¯”æ¨¡æ¿
        async function insertComparisonTemplate() {
            try {
                if (!widgetId) {
                    throw new Error(t.errorWidgetId);
                }

                // è·å–æŒ‚ä»¶çš„çˆ¶å—ä¿¡æ¯
                const widgetBlock = await callAPI('/api/block/getBlockInfo', { id: widgetId });
                if (!widgetBlock.data) {
                    throw new Error(t.errorWidgetInfo);
                }

                // è·å–çˆ¶æ–‡æ¡£çš„æ‰€æœ‰å­å—
                const parentId = widgetBlock.data.rootID;
                const docBlocks = await callAPI('/api/block/getChildBlocks', { id: parentId });
                
                if (!docBlocks.data) {
                    throw new Error(t.errorDocBlocks);
                }

                // æ‰¾åˆ°æŒ‚ä»¶å—çš„ä½ç½®
                const blocks = docBlocks.data;
                const widgetIndex = blocks.findIndex(b => b.id === widgetId);
                
                if (widgetIndex === -1) {
                    throw new Error(t.errorFindWidget);
                }

                // åˆ›å»ºè¶…çº§å—çš„Markdown
                const template = `{{{row
\`\`\`
${t.originalCode}
${t.enterFirstCode}
\`\`\`

\`\`\`
${t.modifiedCode}
${t.enterSecondCode}
\`\`\`
}}}`;

                // åœ¨æŒ‚ä»¶å‰æ’å…¥è¶…çº§å—
                // å¦‚æœæŒ‚ä»¶æ˜¯ç¬¬ä¸€ä¸ªå—ï¼Œæ’å…¥åˆ°çˆ¶å—çš„ç¬¬ä¸€ä¸ªä½ç½®
                // å¦åˆ™æ’å…¥åˆ°å‰ä¸€ä¸ªå—ä¹‹å
                let insertParams;
                if (widgetIndex === 0) {
                    insertParams = {
                        dataType: 'markdown',
                        data: template,
                        parentID: parentId
                    };
                } else {
                    const previousBlockId = blocks[widgetIndex - 1].id;
                    insertParams = {
                        dataType: 'markdown',
                        data: template,
                        previousID: previousBlockId
                    };
                }

                await callAPI('/api/block/insertBlock', insertParams);

                showStatus(t.templateInserted, 'success');
                
                // å»¶è¿Ÿåˆ·æ–°ä»¥ç­‰å¾…å—åˆ›å»ºå®Œæˆ
                setTimeout(() => {
                    loadAndShowDiff();
                }, 1000);

            } catch (error) {
                console.error('Failed to insert template:', error);
                showStatus(t.templateInsertFailed + ': ' + error.message, 'error');
            }
        }

        // LocalStorage key for auto-update preference
        const AUTO_UPDATE_KEY = 'sy-widget-show-diff-auto-update';

        // Load auto-update preference from localStorage
        function loadAutoUpdatePreference() {
            const autoUpdateCheckbox = document.getElementById('autoUpdateCheckbox');
            const savedPreference = localStorage.getItem(AUTO_UPDATE_KEY);
            
            if (savedPreference !== null) {
                // Use saved preference
                autoUpdateCheckbox.checked = savedPreference === 'true';
            } else {
                // Default to checked if no preference saved
                autoUpdateCheckbox.checked = true;
            }
        }

        // Save auto-update preference to localStorage
        function saveAutoUpdatePreference(checked) {
            localStorage.setItem(AUTO_UPDATE_KEY, checked.toString());
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('insertBtn').addEventListener('click', insertComparisonTemplate);
        document.getElementById('refreshBtn').addEventListener('click', loadAndShowDiff);
        document.getElementById('unifiedViewBtn').addEventListener('click', () => switchView('unified'));
        document.getElementById('splitViewBtn').addEventListener('click', () => switchView('split'));
        
        // Listen for auto-update checkbox changes
        document.getElementById('autoUpdateCheckbox').addEventListener('change', (event) => {
            saveAutoUpdatePreference(event.target.checked);
        });

        // åˆå§‹åŒ–ï¼šè·å–è¯­è¨€è®¾ç½®å¹¶è‡ªåŠ¨åŠ è½½
        async function initialize() {
            // Load saved auto-update preference
            loadAutoUpdatePreference();
            
            // Load saved view preference
            const savedView = localStorage.getItem('sy-widget-show-diff-view');
            if (savedView === 'split') {
                currentView = 'split';
                document.getElementById('unifiedViewBtn').classList.remove('active');
                document.getElementById('splitViewBtn').classList.add('active');
            }
            
            await getSiYuanLang();
            
            if (widgetId) {
                loadAndShowDiff();
            } else {
                console.error('Widget ID not found');
                showStatus(t.widgetIdError, 'error');
            }
        }

        // å»¶è¿Ÿåˆå§‹åŒ–ä»¥ç¡®ä¿DOMå®Œå…¨åŠ è½½
        setTimeout(initialize, 1000);

        // å®šæœŸè‡ªåŠ¨åˆ·æ–°ï¼ˆæ¯5ç§’ï¼‰ï¼Œæ ¹æ®checkboxçŠ¶æ€
        setInterval(() => {
            const autoUpdateCheckbox = document.getElementById('autoUpdateCheckbox');
            if (widgetId && autoUpdateCheckbox && autoUpdateCheckbox.checked) {
                loadAndShowDiff();
            }
        }, 5000);
    </script>
</body>
</html>
